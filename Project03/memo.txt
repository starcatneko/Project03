"メモのメモ"
タグの説明
 ##		項目名
 $$		復習
 **		やることメモ
 !!		授業との差異
 
何度回しても初期値から変わらないのはautoが参照ではない可能性がびれ損・・・？

 ** 宿題
 AddPieceの前にやらないといけない事を
 やる。
 （ダミーでいいので何かを入れる？）

 ** PieceTray
 手ごまが無くなった場合
 ノーマル駒を生み出す

 !! PlayerはGameTaskが持っている
	（GameBoard側ではない)


 PieceTrayの描画
 1.PieceTrayの土台を描画
 2.土台を基準にピースを描画
 （PieceTrayのピースのDrauOffsetを土台の基準点にする）
 
void PieceTray::SelectTrayPiece(VECTOR2 pos)
{

}

 ** 10/09 ~ 10/12
	1.キャラ駒の配置


 ## OutputDebugString()
	出力ウィンドウに任意のテキストを表示する
	書式付き文字列は表示できない。

 ## unique_ptrの真偽
	unique_ptrが真の場合存在
	偽の場合は存在していない
	
	if(unique_ptr)	// unique_ptrが存在する場合ifの中に入る
	{
	
	}

 ## デザインパターン state
 Stateパターン
  抽象化したクラス→継承
  メンバは全部純粋仮想関数
  例)クラス PieceState
	 virtual int GetDrawColor() = 0;
	 ↓
	 継承クラス PieceBlack
	 int GetDrawColor() {~~~~return ~~;}

 ** チェック方向のベクトル
 チェック方向を正規化したベクトル
 VECTOR2でテーブルを作る

 player1
 player2

 current pl1
 setpiece
 nextpl plList.next
 current pl2 
 setpiece
 plList.end == current
 ->plList.bigin



 ** おせろ設計
 |→・二人が順に駒を置く（置けないときはスキップ）←-----|
 | ・相手の駒を１個以上　ひっくり返せるか？		(ひっくり返せない)
 | ↓
 | ・駒を置く
 | ↓
 |-・駒をひっくり返す処理

 二人がひっくり返せない場合、ゲーム終了
 ↓
 結果

 GameTask()
	→	
	GameBoard()
		→
		std::list<player>playerList()



 **宿題0913
 シングルトンをGameTaskの形に（デストラクタのPrivate化、Destroy、Create削除）

 ##デストラクタのprivate化
	デストラクタをprivateに書くことで、
	「このクラスを消さないでほしい」という意図を
	表現することができる。
	プログラムの書き方で意思を伝えることが大事

 ##default deleter
	通常はデストラクタ
	unique_ptrの省略可能な第二引数
	デストラクタをprivateで書く場合、
	deleterを作らなければならない
	unique_ptrの第二引数に渡すdeleterは、
	関数オブジェクトで作成する

## 関数オブジェクト
調べよ

## autoとitr
<list>
 |-(itr) -> データ
 |-(itr) -> データ
 |-(itr) -> データ

auto k = piecelist.bigin();
	auto はlistのitrになる
	（型に対して auto)

auto l:piecelist;
	auto はデータになる
	(list全体に対して auto)

	list自体を扱いたい場合は
	前者の書き方じゃないとダメ



リストじゃあああああああ
LRを参照

GameBoard
クリックされた場所をもとに盤面に駒を置く
駒が置かれたら駒のクラス(GamePiece)をインスタンス

置かれた駒が特殊駒だった場合、さらに特殊駒のクラス(GamePiece)を
同じ位置にインスタンスする。

GamePiece
GameBoardにGamePieceのリストを作成する
インスタンスされたらGamePieceのリストにpushする

**隣接する駒を検索する関数つくる


GameBoard
↓
GamePiece
↓
Piece→個別Pieceクラス

=========
→ : 継承

隣接する駒の検索および反転はGameBoardクラスで行うのがよい？